{
  "hash": "de2d44680d2bffc2eeef49c288818d40",
  "result": {
    "markdown": "---\ntitle: \"Challenge 10\"\nauthor: \"Sean Conway\"\ndescription: \"purrr\"\ndate: \"02/02/2023\"\nformat:\n  html:\n    toc: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_10\n  - hotel_bookings\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggplot2)\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n## Challenge Overview\n\nThe [purrr](https://purrr.tidyverse.org/) package is a powerful tool for functional programming. It allows the user to apply a single function across multiple objects. It can replace for loops with a more readable (and often faster) simple function call. \n\nFor example, we can draw `n` random samples from 10 different distributions using a vector of 10 means.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 100 # sample size\nm <- seq(1,10) # means \nsamps <- map(m,rnorm,n=n) \n```\n:::\n\n\nWe can then use `map_dbl` to verify that this worked correctly by computing the mean for each sample.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamps %>%\n  map_dbl(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0.9926729  1.9570364  3.0935696  3.8431738  4.8316432  5.9483288\n [7]  7.0132238  8.0654060  8.7788623 10.0286549\n```\n:::\n:::\n\n\n`purrr` is tricky to learn (but beyond useful once you get a handle on it). Therefore, it's imperative that you complete the `purr` and `map` readings before attempting this challenge.  \n\n## The challenge  \n\nUse `purrr` with a function to perform *some* data science task. What this task is is up to you. It could involve computing summary statistics, reading in multiple datasets, running a random process multiple times, or anything else you might need to do in your work as a data analyst. You might consider using `purrr` with a function you wrote for challenge 9.\n\nI will re-use the dataset I used in Challenge 9 and will compute the Z-Score of the columns, just like I did in Challenge 9.\n\n# Function to compute statistics (z-score)\nz-score = (x - mean) / std_dev\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz_score <- function(col) {\n  output <- (col - mean(col)) / sd(col)\n  return(output)\n}\n```\n:::\n\n\nReading the dataset\n\n::: {.cell}\n\n```{.r .cell-code}\nbookings <- read_csv(\"_data/hotel_bookings.csv\")\n# taking 20 samples\nbookings <- head(bookings, 20)\n```\n:::\n\n\nCalculating the z-score for some of the columns: lead_time, stays_in_week_nights, adr\n\n::: {.cell}\n\n```{.r .cell-code}\noutput <- map(\n  list(bookings$lead_time,\n       bookings$stays_in_week_nights, \n       bookings$adr), \n  z_score)\nhead(output)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n [1]  1.52612471  3.82740076 -0.42559042 -0.39063433 -0.38480831 -0.38480831\n [7] -0.46637253 -0.41393839  0.02883878 -0.02942138 -0.33237417 -0.26246199\n[13] -0.07020348 -0.36150425 -0.25080996 -0.07020348 -0.25080996 -0.39646034\n[19] -0.46637253 -0.42559042\n\n[[2]]\n [1] -1.7018641 -1.7018641 -1.0211185 -1.0211185 -0.3403728 -0.3403728\n [7] -0.3403728 -0.3403728  0.3403728  0.3403728  1.0211185  1.0211185\n[13]  1.0211185  1.0211185  1.0211185  1.0211185  1.0211185 -1.0211185\n[19] -1.0211185  1.0211185\n\n[[3]]\n [1] -2.400562779 -2.400562779 -0.506478213 -0.506478213  0.074374387\n [6]  0.074374387  0.301664535  0.200646692 -0.329696987  0.263782844\n[11]  0.705735909  1.261334049  0.049119926  1.508070131 -0.008712789\n[16]  0.049119926  0.061747157 -0.173119329  0.312271409  1.463369736\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}