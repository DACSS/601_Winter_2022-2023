{
  "hash": "335d8cb2bc22ad4b2369fd057c3d4010",
  "result": {
    "markdown": "---\ntitle: \"Challenge 10 Solutions\"\nauthor: \"Sean Conway\"\ndescription: \"purrr\"\ndate: \"1/30/2023\"\nformat:\n  html:\n    toc: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_10\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n## Challenge Overview\n\nThe [purrr](https://purrr.tidyverse.org/) package is a powerful tool for functional programming. It allows the user to apply a single function across multiple objects. It can replace for loops with a more readable (and often faster) simple function call. \n\nFor example, we can draw `n` random samples from 10 different distributions using a vector of 10 means.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 100 # sample size\nm <- seq(1,10) # means \nsamps <- map(m,rnorm,n=n) \n```\n:::\n\n\nWe can then use `map_dbl` to verify that this worked correctly by computing the mean for each sample.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamps %>%\n  map_dbl(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.026488 2.012884 3.205673 4.063786 5.155286 6.088816 7.064965 7.939685\n [9] 9.012769 9.988608\n```\n:::\n:::\n\n\n`purrr` is tricky to learn (but beyond useful once you get a handle on it). Therefore, it's imperative that you complete the `purr` and `map` readings before attempting this challenge.  \n\n## The challenge  \n\nUse `purrr` with a function to perform *some* data science task. What this task is is up to you. It could involve computing summary statistics, reading in multiple datasets, running a random process multiple times, or anything else you might need to do in your work as a data analyst. You might consider using `purrr` with a function you wrote for challenge 9.  \n\n## Solutions  \n\nThere are innumerable ways to use `purrr` in your coding. To demonstrate just a few, I'll use some of the functions I created in [Challenge 9](https://dacss.github.io/601_Winter_2022-2023/posts/challenge9_solutions.html)  \n\n## Using `purrr` to perofrm simple computations  \n\nLet's use the `map_dbl()` function to compute the mean for each of several variables. \n\nBelow, we use the the `map_dbl()` function to compute the mean for multiple variables from the `mtcars` dataset (specifically weight, horsepower, and miles-per-gallon). We use `map_dbl()` because we know the result of computing the mean will be of data type `double`. This allows `purrr` to simplify the output. We also combine the variables in a `list` when passing them to `map_dbl()`.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the dataset\nmtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_dbl(list(mtcars$wt, mtcars$hp, mtcars$mpg),mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   3.21725 146.68750  20.09062\n```\n:::\n:::\n\n\nThe above operation gives us a vector of means. If we use regular old `map`, the operation still works fine, but we get a list object (which can be a little more annoying to work with).  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(list(mtcars$wt, mtcars$hp, mtcars$mpg),mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 3.21725\n\n[[2]]\n[1] 146.6875\n\n[[3]]\n[1] 20.09062\n```\n:::\n:::\n\n\n## A function that computes multiple summary statistics  \n\nI modified this function to include a required \"id\" value. This will allow us to use `map2_dfr()` to apply the function across multiple columns and bind the results into a single data frame, while allowing the variable itself to be identifiable. I also modified the function to compute the [standard error](https://en.wikipedia.org/wiki/Standard_error).  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_stat <- function(x,id){\n  stat <- tibble(\n    id=id,\n    mean=mean(x,na.rm=T),\n    median=median(x,na.rm=T),\n    sd=sd(x,na.rm=T),\n    se=sd/sqrt(length(x))\n  )\n  return(stat)\n}\n```\n:::\n\n\nWe'll use the `mtcars` dataset.  \n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n:::\n:::\n\n  \nIn the example below, we compute the mean, median, sd, and se for `mpg` (miles per gallon), `hp` (horsepower), and `wt` (weight) in the `mtcars` dataset. We use `map2_dfr()` to do so. We need to use one of the [map2](https://purrr.tidyverse.org/reference/map2.html) variations because we need to concurrently pass the vector of numerical values and the character identifier we're using for this variable (e.g., both `mtcars$mpg` and `\"mpg\"`).  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_stats <- map2_dfr(list(mtcars$mpg, mtcars$hp, mtcars$wt), \n         list(\"mpg\",\"hp\",\"wt\"),\n         sum_stat)\nmtcars_stats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n  id      mean median     sd     se\n  <chr>  <dbl>  <dbl>  <dbl>  <dbl>\n1 mpg    20.1   19.2   6.03   1.07 \n2 hp    147.   123    68.6   12.1  \n3 wt      3.22   3.32  0.978  0.173\n```\n:::\n:::\n\n\nWe can even use `pivot_longer()` to get a \"long\" format of these statistics.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_stats_long <- mtcars_stats %>%\n  pivot_longer(c(-id))\nmtcars_stats_long\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 12 × 3\n   id    name     value\n   <chr> <chr>    <dbl>\n 1 mpg   mean    20.1  \n 2 mpg   median  19.2  \n 3 mpg   sd       6.03 \n 4 mpg   se       1.07 \n 5 hp    mean   147.   \n 6 hp    median 123    \n 7 hp    sd      68.6  \n 8 hp    se      12.1  \n 9 wt    mean     3.22 \n10 wt    median   3.32 \n11 wt    sd       0.978\n12 wt    se       0.173\n```\n:::\n:::\n\n\n### A `purrr` pipeline  \n\nBelow, I fully demonstrate how we can use our function in a pipeline that begins with `purrr` and ends with us using `ggplot` to visualize the mean and se for each of these numerical variables.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# compute summary stats\nmap2_dfr(list(mtcars$mpg, mtcars$hp, mtcars$wt), \n         list(\"miles per gallon\",\"horse power\",\"weight\"),\n         sum_stat) %>%\n  mutate(se_lower=mean-se, # get lower and upper bounds for error bars\n         se_upper=mean+se) %>%\n  ggplot(aes(id,mean))+\n  geom_col(fill=\"lightblue\")+ # visualize w/ geom_col\n  geom_errorbar(aes(ymin=se_lower,ymax=se_upper),width=.25)+ # add error bars\n  labs(x=\"variable\",y=\"mean value\",caption=\"Error bars are +- 1 SE of the mean.\")+\n  ggthemes::theme_clean()+\n  theme(plot.caption=element_text(hjust=-.5))\n```\n\n::: {.cell-output-display}\n![](challenge10_solutions_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nThis plot might not be the best use of `ggplot`. The units of these variables are so different - for example, `wt` is measured in tons, so it's very difficult to see where exactly the mean lies. So take this as an example of what you *can* do with `purrr`, when it makes sense for your research question.  \n\n## A function that plots a histogram  \n\nIn Challenge 9, we made a function that creates a histogram using ggplot. Here, we use it to make multiple histograms using `map()`.  \n\nWe have to modify the function using [defusion](https://rlang.r-lib.org/reference/topic-defuse.html)^[This is beyond the scope of the challenge/this course. If you're interested, you are welcome to read more about it. The main point here is we're using some fancy `R` functions to grab the column names we want from the `mtcars` data frame.].  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_my_hist <- function(dat, colname, fill=\"purple\", xlab=\"x\", ylab=\"n\"){\n  colname <- rlang::ensym(colname)\n  dat %>%\n    ggplot(aes({{colname}}))+\n    geom_histogram(fill=fill)+\n    labs(x=colname,\n         y=ylab)\n}\n```\n:::\n\n\n### Making the histograms  \n\nWe pass the names of the variables we want to graph to the `make_my_hist()` function. We use `!!`, or [bang-bang](https://www.r-bloggers.com/2019/07/bang-bang-how-to-program-with-dplyr/) to make sure the function works appropriately.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(c(\"mpg\", \"hp\", \"wt\"), ~make_my_hist(dat=mtcars, colname=!!.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n```\n:::\n\n::: {.cell-output-display}\n![](challenge10_solutions_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n[[2]]\n```\n:::\n\n::: {.cell-output-display}\n![](challenge10_solutions_files/figure-html/unnamed-chunk-13-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n[[3]]\n```\n:::\n\n::: {.cell-output-display}\n![](challenge10_solutions_files/figure-html/unnamed-chunk-13-3.png){width=672}\n:::\n:::\n\n\n## A function that computes counts of a categorical variable  \n\nWhen a variable is categorical, we typically summarise it by computing the counts (or frequencies) of each value. Base `R` uses the `table()` function to do so, but the result is of class `\"table\"`, which is not always amenable to a tidyverse programmer. \n\nThe below function uses the `sum()` function add up the counts of each unique value in a categorical variable. A second, optional argument allows the user to compute proportions as well (also known as relative frequencies).^[A user might also use the `dplyr` functions `n()` or `count()`, though these have drawbacks of their own].  \n\n### The function  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# function for counting\ntable_data <- function(x, props=F){\n  # get all unique values of x\n  v <- unique(x)\n  \n  # using purrr, count the num of values at each unique level of x\n  counts <- map_dbl(v, ~sum(x==.x))\n  \n  # combine results in a tibble\n  res <- tibble(\n    name=v,\n    n=counts\n  )\n  \n  # compute props if desired\n  if(props){\n    res <- res %>%\n      mutate(prop=n/sum(n))\n  }\n  return(res)\n}\n```\n:::\n\n\n\n### Using the functions  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# randomly sampled vector\nvec <- sample(c(\"a\",\"b\",\"c\"),size=1000,replace=T)\nhead(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"b\" \"c\" \"c\" \"b\" \"c\" \"a\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# count w/o props\ntable_data(vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  name      n\n  <chr> <dbl>\n1 b       325\n2 c       323\n3 a       352\n```\n:::\n\n```{.r .cell-code}\n# count w/ props\ntable_data(vec,T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  name      n  prop\n  <chr> <dbl> <dbl>\n1 b       325 0.325\n2 c       323 0.323\n3 a       352 0.352\n```\n:::\n:::\n\n\n## Wrapping up  \n\nThe above examples are just a few ways you can use `purrr` to implement functional programming in `R`. ",
    "supporting": [
      "challenge10_solutions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}